___________________________________________________________________________
Задача:
1)читаем файлы STL (опционально выводим изображения)
2)спрашиваем у пользователя сколько средних сегментов добавить в сколопендру
3)генерируем новый STL документ с необходимым количеством сегментов
 ___________________________________________________________________________
 Решение:
 1)Разобраться хранятся ли координаты объектов в STL файлах или они по умолчанию в центре координат 
 2)Разобраться с размерностью в файле стл (мм,см и т.д.)
 
 3)Просим пользователя ввести количество сегментов  - (count)
 4)Получаем количество треугольников из каждого STL файла  - (head.trisCount, back.trisCount, mid.trisCount)
 5)Пишем заголовок в новый файл STL(копируем первые 80 байт из любого файла)
 6)Пишем количество треугольников в новый STL - (head.trisCount + back.trisCount + (mid.trisCount * count))
 7)Копируем треугольники из Head.stl в новый STL
 8)Циклично копируем необходимое количество копий Middle.stl в новый STL c вычисленной сдвижкой
 9)Копирум в вычисленное положение треугольники из Tail.STL 
 
___________________________________________________________________________
UINT8[80]    – Header                 -     80 bytes
UINT32       – Number of triangles    -      4 bytes
foreach triangle                      - 50 bytes:
    REAL32[3] – Normal vector             - 12 bytes
    REAL32[3] – Vertex 1                  - 12 bytes
    REAL32[3] – Vertex 2                  - 12 bytes
    REAL32[3] – Vertex 3                  - 12 bytes
    UINT16    – Attribute byte count      -  2 bytes
end
___________________________________________________________________________
Вычисление положения первого сегмента:
1)Находим длину по X основного элемента (head.lengthX)
2)Находим длину по Х добавляемого сегмента (mid.lengthX)
3)Центр первого добавляемого сегмента будет в точке (head.lengthX/2) + (mid.lengthX/2)-(delta)
___________________________________________________________________________
Вычисление каждого следующего положения:
1)Центральное положение n-го элемента - (head.lengthX/2) + (mid.lengthX/2)-(delta) + (n*(mid.lengthX-delta)
___________________________________________________________________________
Вычисление положения хвоста:
1)Центральное положение хвоста - (head.lengthX/2) + (mid.lengthX/2)-(delta) + ((count-1)*(mid.lengthX-delta) + ((back.lengthX/2)-delta)
